<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>B&S ModOption Generator Pro</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
      color: #eee;
      padding: 20px;
      margin: 0;
      min-height: 100vh;
    }
    .container {
      max-width: 1600px;
      margin: 0 auto;
    }
    h1 {
      color: #0078ff;
      text-shadow: 0 0 10px rgba(0, 120, 255, 0.5);
      margin-bottom: 10px;
    }
    .section {
      background: rgba(30, 30, 30, 0.8);
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    .config-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }
    .config-item {
      display: flex;
      flex-direction: column;
    }
    label {
      color: #aaa;
      font-size: 13px;
      margin-bottom: 5px;
      font-weight: 600;
    }
    input[type="text"], input[type="number"], select, textarea {
      background: #1e1e1e;
      border: 1px solid #333;
      color: #eee;
      padding: 8px 12px;
      border-radius: 4px;
      font-family: Consolas, monospace;
      font-size: 13px;
    }
    input[type="text"]:focus, input[type="number"]:focus, select:focus, textarea:focus {
      outline: none;
      border-color: #0078ff;
      box-shadow: 0 0 0 2px rgba(0, 120, 255, 0.2);
    }
    input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }
    .checkbox-wrapper {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }
    textarea {
      min-height: 250px;
      resize: vertical;
    }
    pre {
      background: #0d1117;
      color: #9cff9c;
      padding: 20px;
      border-radius: 6px;
      min-height: 300px;
      white-space: pre-wrap;
      border: 1px solid #30363d;
      overflow-x: auto;
      font-size: 13px;
      line-height: 1.5;
    }
    button {
      background: linear-gradient(135deg, #0078ff 0%, #0056cc 100%);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 6px;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0, 120, 255, 0.3);
    }
    button:hover {
      background: linear-gradient(135deg, #0056cc 0%, #003d99 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 120, 255, 0.4);
    }
    button:active {
      transform: translateY(0);
    }
    .button-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .info {
      background: rgba(0, 120, 255, 0.1);
      border-left: 3px solid #0078ff;
      padding: 12px;
      margin-bottom: 20px;
      border-radius: 4px;
      font-size: 13px;
    }
    .warning {
      background: rgba(255, 193, 7, 0.1);
      border-left: 3px solid #ffc107;
      padding: 12px;
      margin-bottom: 20px;
      border-radius: 4px;
      font-size: 13px;
    }
    code {
      background: rgba(255, 255, 255, 0.1);
      padding: 2px 6px;
      border-radius: 3px;
      font-family: Consolas, monospace;
    }
    .toggle-section {
      cursor: pointer;
      user-select: none;
      padding: 10px;
      background: rgba(0, 120, 255, 0.2);
      border-radius: 4px;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .toggle-section:hover {
      background: rgba(0, 120, 255, 0.3);
    }
    .collapsible-content {
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    .member-type-select {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin-bottom: 15px;
    }
    .member-type-btn {
      padding: 10px;
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid #333;
      border-radius: 6px;
      cursor: pointer;
      text-align: center;
      transition: all 0.2s;
    }
    .member-type-btn:hover {
      border-color: #0078ff;
      background: rgba(0, 120, 255, 0.1);
    }
    .member-type-btn.active {
      border-color: #0078ff;
      background: rgba(0, 120, 255, 0.2);
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>‚öîÔ∏è Blade & Sorcery ModOption Generator Pro</h1>
    <p style="color: #888;">Advanced tool for generating ModOption code with full B&S SDK support</p>

    <div class="section">
      <h3>Quick Settings</h3>
      <div class="config-grid">
        <div class="config-item">
          <label>Member Type</label>
          <select id="memberType">
            <option value="property">Property (Recommended)</option>
            <option value="field">Field</option>
            <option value="method">Method</option>
          </select>
        </div>
        <div class="config-item">
          <label>Access Modifier</label>
          <select id="accessModifier">
            <option value="public">public</option>
            <option value="private">private</option>
            <option value="internal">internal</option>
          </select>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="toggle-section" onclick="toggleSection('advancedConfig')">
        <span><strong>‚öôÔ∏è Advanced Configuration</strong></span>
        <span id="advancedToggle">‚ñº</span>
      </div>
      <div id="advancedConfig" class="collapsible-content" style="max-height: 2000px;">
        <div class="config-grid">
          <div class="config-item">
            <label>Category Name</label>
            <input type="text" id="categoryName" placeholder="Leave empty for no category" />
          </div>
          <div class="config-item">
            <label>Category Order</label>
            <input type="number" id="categoryOrder" value="0" />
          </div>
          <div class="config-item">
            <label>Option Order</label>
            <input type="number" id="optionOrder" value="0" />
          </div>
        </div>

        <h4 style="margin-top: 20px; color: #0078ff;">Type-Specific Settings</h4>
        
        <div class="checkbox-wrapper">
          <input type="checkbox" id="useSeparateAttributes" checked />
          <label for="useSeparateAttributes">Use Separate Attributes (Recommended for readability)</label>
        </div>

        <h4 style="margin-top: 15px;">Boolean Options</h4>
        <div class="checkbox-wrapper">
          <input type="checkbox" id="boolUseButton" checked />
          <label for="boolUseButton">Use [ModOptionButton] for bools</label>
        </div>
        <div class="checkbox-wrapper">
          <input type="checkbox" id="boolUseArrows" />
          <label for="boolUseArrows">Use [ModOptionArrows] for bools</label>
        </div>

        <h4 style="margin-top: 15px;">Float/Int Options</h4>
        <div class="checkbox-wrapper">
          <input type="checkbox" id="numericUseSlider" checked />
          <label for="numericUseSlider">Use [ModOptionSlider] for float/int</label>
        </div>
        <div class="checkbox-wrapper">
          <input type="checkbox" id="numericGenerateValueSource" />
          <label for="numericGenerateValueSource">Generate custom value source method (avoids double/float conversion)</label>
        </div>
        <div class="checkbox-wrapper">
          <input type="checkbox" id="separateValueSources" checked />
          <label for="separateValueSources">Output value source methods separately at the bottom</label>
        </div>
        <div class="config-grid" style="margin-top: 10px;">
          <div class="config-item">
            <label>Float Min</label>
            <input type="number" id="floatMin" value="0" step="0.1" />
          </div>
          <div class="config-item">
            <label>Float Max</label>
            <input type="number" id="floatMax" value="100" step="0.1" />
          </div>
          <div class="config-item">
            <label>Float Step</label>
            <input type="number" id="floatStep" value="0.1" step="0.01" />
          </div>
          <div class="config-item">
            <label>Int Min</label>
            <input type="number" id="intMin" value="0" />
          </div>
          <div class="config-item">
            <label>Int Max</label>
            <input type="number" id="intMax" value="100" />
          </div>
          <div class="config-item">
            <label>Int Step</label>
            <input type="number" id="intStep" value="1" />
          </div>
        </div>

        <h4 style="margin-top: 15px;">Save Behavior</h4>
        <div class="checkbox-wrapper">
          <input type="checkbox" id="saveValues" checked />
          <label for="saveValues">Save values to player save file (default is true)</label>
        </div>

        <h4 style="margin-top: 15px;">Tooltips & Localization</h4>
        <div class="checkbox-wrapper">
          <input type="checkbox" id="addTooltips" />
          <label for="addTooltips">Add tooltip placeholders</label>
        </div>
        <div class="checkbox-wrapper">
          <input type="checkbox" id="addLocalization" />
          <label for="addLocalization">Add localization ID placeholders</label>
        </div>
      </div>
    </div>

    <div class="section">
      <h3>Input Code</h3>
      <div class="info">
        <strong>Supported formats:</strong><br>
        ‚Ä¢ <code>private const float MySpeed = 5.0f;</code><br>
        ‚Ä¢ <code>public static int MaxHealth = 100;</code><br>
        ‚Ä¢ <code>const bool EnableFeature = true;</code><br>
        ‚Ä¢ <code>float Range = 24;</code> (any variable declaration)<br>
        ‚Ä¢ <code>int Count;</code> (declarations without values)<br>
        ‚Ä¢ Supports: <code>float</code>, <code>int</code>, <code>bool</code>, <code>string</code>, <code>Color</code>
      </div>
      <textarea id="input" placeholder="float MySpeed = 5.0f;&#10;int MaxHealth = 100;&#10;bool EnableFeature = true;&#10;float Range = 24;&#10;&#10;// Works with or without const/static/access modifiers!"></textarea>
    </div>

    <div class="button-group">
      <button id="generate">üöÄ Generate ModOptions</button>
      <button id="copy" style="background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%);">üìã Copy to Clipboard</button>
      <button id="clear" style="background: linear-gradient(135deg, #dc3545 0%, #a71d2a 100%);">üóëÔ∏è Clear All</button>
    </div>

    <div class="section">
      <h3>Generated Output</h3>
      <div class="warning">
        <strong>‚ö†Ô∏è Important:</strong> Remember to add <code>static</code> to your generated members! All ModOptions must be static.
      </div>
      <pre id="output">// Your generated code will appear here...
// Paste your constants in the input box above and click Generate!</pre>
    </div>
  </div>

  <script>
    const elements = {
      input: document.getElementById("input"),
      output: document.getElementById("output"),
      generate: document.getElementById("generate"),
      copy: document.getElementById("copy"),
      clear: document.getElementById("clear"),
      memberType: document.getElementById("memberType"),
      accessModifier: document.getElementById("accessModifier"),
      categoryName: document.getElementById("categoryName"),
      categoryOrder: document.getElementById("categoryOrder"),
      optionOrder: document.getElementById("optionOrder"),
      useSeparateAttributes: document.getElementById("useSeparateAttributes"),
      boolUseButton: document.getElementById("boolUseButton"),
      boolUseArrows: document.getElementById("boolUseArrows"),
      numericUseSlider: document.getElementById("numericUseSlider"),
      floatMin: document.getElementById("floatMin"),
      floatMax: document.getElementById("floatMax"),
      floatStep: document.getElementById("floatStep"),
      intMin: document.getElementById("intMin"),
      intMax: document.getElementById("intMax"),
      intStep: document.getElementById("intStep"),
      numericGenerateValueSource: document.getElementById("numericGenerateValueSource"),
      separateValueSources: document.getElementById("separateValueSources"),
      saveValues: document.getElementById("saveValues"),
      addTooltips: document.getElementById("addTooltips"),
      addLocalization: document.getElementById("addLocalization")
    };

    function toggleSection(id) {
      const content = document.getElementById(id);
      const toggle = document.getElementById(id.replace('Config', 'Toggle'));
      if (content.style.maxHeight === '0px') {
        content.style.maxHeight = '2000px';
        toggle.textContent = '‚ñº';
      } else {
        content.style.maxHeight = '0px';
        toggle.textContent = '‚ñ∂';
      }
    }

    function formatName(name) {
      return name.replace(/([A-Z])/g, " $1").trim();
    }

    function toLowerFirst(str) {
      return str[0].toLowerCase() + str.slice(1);
    }

    function generateModOption(type, name, value, config) {
      const readableName = formatName(name);
      const lowerType = type.toLowerCase();
      let memberName = name;
      let cleanValue = value.trim();
      let valueSourceMethod = null;
      let valueSourceMethodName = null;
      
      let attributes = [];
      let modOptionParams = [];

      if (config.categoryName) {
        if (config.useSeparateAttributes) {
          let catAttr = `[ModOptionCategory("${config.categoryName}"`;
          if (config.categoryOrder !== 0) {
            catAttr += `, ${config.categoryOrder}`;
          }
          catAttr += `)]`;
          attributes.push(catAttr);
        } else {
          modOptionParams.push(`category: "${config.categoryName}"`);
          if (config.categoryOrder !== 0) {
            modOptionParams.push(`categoryOrder: ${config.categoryOrder}`);
          }
        }
      }

      if (config.optionOrder !== 0) {
        if (config.useSeparateAttributes) {
          attributes.push(`[ModOptionOrder(${config.optionOrder})]`);
        } else {
          modOptionParams.push(`order: ${config.optionOrder}`);
        }
      }

      if (!config.saveValues) {
        if (config.useSeparateAttributes) {
          attributes.push(`[ModOptionDontSave]`);
        } else {
          modOptionParams.push(`saveValue: false`);
        }
      }

      if (lowerType === "float") {
        cleanValue = cleanValue.replace(/f$/i, "") + "f";
        
        if (config.numericGenerateValueSource) {
          valueSourceMethodName = `${memberName}Options`;
          const min = parseFloat(config.floatMin);
          const max = parseFloat(config.floatMax);
          const step = parseFloat(config.floatStep);
          const count = Math.floor((max - min) / step) + 1;
          
          valueSourceMethod = `public static ModOptionFloat[] ${valueSourceMethodName}()
{
    var options = new ModOptionFloat[${count}];
    for (var i = 0; i < ${count}; i++)
    {
        var value = ${min}f + i * ${step}f;
        options[i] = new ModOptionFloat($"{value:F1}", value);
    }
    return options;
}`;
          
          modOptionParams.push(`nameof(${valueSourceMethodName})`);
        } else if (config.numericUseSlider) {
          attributes.push(`[ModOptionSlider]`);
          attributes.push(`[ModOptionFloatValues(${config.floatMin}f, ${config.floatMax}f, ${config.floatStep}f)]`);
        }
      } else if (lowerType === "int") {
        cleanValue = cleanValue.replace(/[^0-9-]/g, "");
        
        if (config.numericGenerateValueSource) {
          valueSourceMethodName = `${memberName}Options`;
          const min = parseInt(config.intMin);
          const max = parseInt(config.intMax);
          const step = parseInt(config.intStep);
          const count = Math.floor((max - min) / step) + 1;
          
          valueSourceMethod = `public static ModOptionInt[] ${valueSourceMethodName}()
{
    var options = new ModOptionInt[${count}];
    for (var i = 0; i < ${count}; i++)
    {
        var value = ${min} + i * ${step};
        options[i] = new ModOptionInt(value.ToString(), value);
    }
    return options;
}`;
          
          modOptionParams.push(`nameof(${valueSourceMethodName})`);
        } else if (config.numericUseSlider) {
          attributes.push(`[ModOptionSlider]`);
          attributes.push(`[ModOptionIntValues(${config.intMin}, ${config.intMax}, ${config.intStep})]`);
        }
      } else if (lowerType === "bool") {
        cleanValue = cleanValue.toLowerCase() === "true" ? "true" : "false";
        if (config.boolUseButton) {
          attributes.push(`[ModOptionButton]`);
        } else if (config.boolUseArrows) {
          attributes.push(`[ModOptionArrows]`);
        }
      } else if (lowerType === "string") {
        if (!cleanValue.startsWith('"')) cleanValue = '"' + cleanValue;
        if (!cleanValue.endsWith('"')) cleanValue = cleanValue + '"';
      } else if (lowerType === "color") {
      }

      if (config.addTooltips) {
        if (config.useSeparateAttributes) {
          let tooltipAttr = `[ModOptionTooltip("Description for ${readableName}"`;
          if (config.addLocalization) {
            tooltipAttr += `, "YourMod.${memberName}.Tooltip"`;
          }
          tooltipAttr += `)]`;
          attributes.push(tooltipAttr);
        } else {
          modOptionParams.push(`tooltip: "Description for ${readableName}"`);
          if (config.addLocalization) {
            modOptionParams.push(`tooltipLocalizationId: "YourMod.${memberName}.Tooltip"`);
          }
        }
      }

     let modOptionAttr = `[ModOption("${readableName}"`;
      
      if (modOptionParams.length > 0) {
        modOptionAttr += `, ${modOptionParams.join(", ")}`;
      }
      
      if (config.addLocalization && !config.addTooltips) {
        if (modOptionParams.length > 0) {
          modOptionAttr += `, titleLocalizationId: "YourMod.${memberName}.Title"`;
        } else {
          modOptionAttr += `, titleLocalizationId: "YourMod.${memberName}.Title"`;
        }
      }
      
      modOptionAttr += `)]`;
      attributes.push(modOptionAttr);

      let memberDeclaration = "";
      const access = config.accessModifier;
      
      if (config.memberType === "field") {
        memberDeclaration = `${access} static ${lowerType} ${memberName} = ${cleanValue};`;
      } else if (config.memberType === "property") {
        memberDeclaration = `${access} static ${lowerType} ${memberName} { get; set; } = ${cleanValue};`;
      } else if (config.memberType === "method") {
        memberDeclaration = `${access} static void ${memberName}(${lowerType} value)\n{\n    // TODO: Implement logic for ${readableName}\n}`;
      }

      let result = attributes.join("\n") + "\n" + memberDeclaration;
      
      return {
        code: result,
        valueSourceMethod: valueSourceMethod,
        valueSourceMethodName: valueSourceMethodName
      };
    }

    function generate() {
      const code = elements.input.value;
      const config = {
        memberType: elements.memberType.value,
        accessModifier: elements.accessModifier.value,
        categoryName: elements.categoryName.value.trim(),
        categoryOrder: parseInt(elements.categoryOrder.value) || 0,
        optionOrder: parseInt(elements.optionOrder.value) || 0,
        useSeparateAttributes: elements.useSeparateAttributes.checked,
        boolUseButton: elements.boolUseButton.checked,
        boolUseArrows: elements.boolUseArrows.checked,
        numericUseSlider: elements.numericUseSlider.checked,
        floatMin: elements.floatMin.value,
        floatMax: elements.floatMax.value,
        floatStep: elements.floatStep.value,
        intMin: elements.intMin.value,
        intMax: elements.intMax.value,
        intStep: elements.intStep.value,
        numericGenerateValueSource: elements.numericGenerateValueSource.checked,
        separateValueSources: elements.separateValueSources.checked,
        saveValues: elements.saveValues.checked,
        addTooltips: elements.addTooltips.checked,
        addLocalization: elements.addLocalization.checked
      };


      const regex = /(?:private|public|protected|internal|static|const|readonly)?\s*(\w+)\s+(\w+)\s*(?:=\s*([^;]+))?;/gi;
      let match;
      let results = [];
      let valueSources = [];

      while ((match = regex.exec(code))) {
        let [_, type, name, value] = match;
        
        const skipKeywords = ['var', 'using', 'namespace', 'class', 'struct', 'enum', 'interface', 'return', 'if', 'else', 'for', 'while', 'foreach'];
        if (skipKeywords.includes(type.toLowerCase())) {
          continue;
        }
        
        if (!value) {
          value = getDefaultValue(type);
        }
        
        const result = generateModOption(type, name, value, config);
        results.push(result.code);
        
        if (result.valueSourceMethod) {
          valueSources.push(result.valueSourceMethod);
        }
      }

      if (results.length === 0) {
        elements.output.textContent = `// No constants detected.
// 
// Supported formats:
// private const float MyValue = 5.0f;
// public static int Count = 10;
// const bool IsEnabled = true;
//
// Make sure your declarations end with semicolons!`;
      } else {
        let output = "";
        
        if (config.separateValueSources && valueSources.length > 0) {
          output += "// ===== ModOption Declarations =====\n\n";
          output += results.join("\n\n");
          output += "\n\n// ===== Value Source Methods =====\n";
          output += "// Place these at the bottom of your class or in a separate region\n\n";
          output += valueSources.join("\n\n");
        } else {
          output = results.join("\n\n");
        }
        
        elements.output.textContent = output;
      }
    }

    function getDefaultValue(type) {
      const lowerType = type.toLowerCase();
      switch (lowerType) {
        case "float": return "0.0f";
        case "int": return "0";
        case "bool": return "false";
        case "string": return '""';
        case "color": return "Color.white";
        default: return "default";
      }
    }

    elements.generate.addEventListener("click", generate);

    elements.copy.addEventListener("click", async () => {
      const text = elements.output.textContent;
      if (text && !text.startsWith("//")) {
        try {
          await navigator.clipboard.writeText(text);
          const originalText = elements.copy.textContent;
          elements.copy.textContent = "‚úÖ Copied!";
          setTimeout(() => {
            elements.copy.textContent = originalText;
          }, 2000);
        } catch (err) {
          alert("Failed to copy to clipboard");
        }
      }
    });

    elements.clear.addEventListener("click", () => {
      if (confirm("Clear input and output?")) {
        elements.input.value = "";
        elements.output.textContent = "// Your generated code will appear here...\n// Paste your constants in the input box above and click Generate!";
      }
    });

    elements.boolUseButton.addEventListener("change", () => {
      if (elements.boolUseButton.checked) {
        elements.boolUseArrows.checked = false;
      }
    });

    elements.boolUseArrows.addEventListener("change", () => {
      if (elements.boolUseArrows.checked) {
        elements.boolUseButton.checked = false;
      }
    });

    let debounceTimer;
    elements.input.addEventListener("input", () => {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(generate, 700);
    });
  </script>
</body>
</html>
