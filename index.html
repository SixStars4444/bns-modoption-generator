<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" type="image/png" href="Imgage.png" />
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>B&S ModOption Generator</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
      color: #eee;
      padding: 20px;
      margin: 0;
      min-height: 100vh;
    }
    .container {
      max-width: 1600px;
      margin: 0 auto;
    }
    h1 {
      color: #0078ff;
      text-shadow: 0 0 10px rgba(0, 120, 255, 0.5);
      margin-bottom: 10px;
    }
    .section {
      background: rgba(30, 30, 30, 0.8);
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    .config-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }
    .config-item {
      display: flex;
      flex-direction: column;
    }
    label {
      color: #aaa;
      font-size: 13px;
      margin-bottom: 5px;
      font-weight: 600;
    }
    input[type="text"], input[type="number"], select, textarea {
      background: #1e1e1e;
      border: 1px solid #333;
      color: #eee;
      padding: 8px 12px;
      border-radius: 4px;
      font-family: Consolas, monospace;
      font-size: 13px;
    }
    input[type="text"]:focus, input[type="number"]:focus, select:focus, textarea:focus {
      outline: none;
      border-color: #0078ff;
      box-shadow: 0 0 0 2px rgba(0, 120, 255, 0.2);
    }
    input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }
    .checkbox-wrapper {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }
    textarea {
      min-height: 250px;
      resize: vertical;
    }
    pre {
      background: #0d1117;
      color: #9cff9c;
      padding: 20px;
      border-radius: 6px;
      min-height: 300px;
      white-space: pre-wrap;
      border: 1px solid #30363d;
      overflow-x: auto;
      font-size: 13px;
      line-height: 1.5;
    }
    button {
      background: linear-gradient(135deg, #0078ff 0%, #0056cc 100%);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 6px;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0, 120, 255, 0.3);
    }
    button:hover {
      background: linear-gradient(135deg, #0056cc 0%, #003d99 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 120, 255, 0.4);
    }
    button:active {
      transform: translateY(0);
    }
    .button-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .info {
      background: rgba(0, 120, 255, 0.1);
      border-left: 3px solid #0078ff;
      padding: 12px;
      margin-bottom: 20px;
      border-radius: 4px;
      font-size: 13px;
    }
    .warning {
      background: rgba(255, 193, 7, 0.1);
      border-left: 3px solid #ffc107;
      padding: 12px;
      margin-bottom: 20px;
      border-radius: 4px;
      font-size: 13px;
    }
    .error {
      background: rgba(220, 53, 69, 0.1);
      border-left: 3px solid #dc3545;
      padding: 12px;
      margin-bottom: 20px;
      border-radius: 4px;
      font-size: 13px;
    }
    code {
      background: rgba(255, 255, 255, 0.1);
      padding: 2px 6px;
      border-radius: 3px;
      font-family: Consolas, monospace;
    }
    .toggle-section {
      cursor: pointer;
      user-select: none;
      padding: 10px;
      background: rgba(0, 120, 255, 0.2);
      border-radius: 4px;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .toggle-section:hover {
      background: rgba(0, 120, 255, 0.3);
    }
    .collapsible-content {
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    .sortable {
      list-style-type: none;
      padding: 0;
    }
    .sortable li {
      margin: 5px 0;
      padding: 10px;
      background: #1e1e1e;
      border: 1px solid #333;
      border-radius: 4px;
      cursor: move;
      display: flex;
      align-items: center;
    }
    .sortable li::before {
      content: "☰";
      margin-right: 10px;
      color: #aaa;
    }
    .dragging {
      opacity: 0.5;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Blade & Sorcery ModOption Generator</h1>
    <p style="color: #888;">Advanced tool for generating ModOption code</p>

<div class="section">
  <h3>Quick Settings</h3>
  <div class="config-grid">
    <div class="config-item">
      <label>Member Type</label>
      <select id="memberType">
        <option value="property">Property (Recommended)</option>
        <option value="field">Field</option>
        <option value="method">Method</option>
      </select>
    </div>
    <div class="config-item">
      <label>Access Modifier</label>
      <select id="accessModifier">
        <option value="public">public</option>
        <option value="private">private</option>
        <option value="internal">internal</option>
      </select>
    </div>
  </div>
</div>

<div class="section">
  <div class="toggle-section" onclick="toggleSection('advancedConfig')">
    <span><strong>⚙️ Advanced Configuration</strong></span>
    <span id="advancedToggle">▼</span>
  </div>
  <div id="advancedConfig" class="collapsible-content" style="max-height: 2000px;">
    <div class="config-grid">
      <div class="config-item">
        <label>Category Name</label>
        <input type="text" id="categoryName" placeholder="Leave empty for no category" />
      </div>
      <div class="config-item">
        <label>Category Order</label>
        <input type="number" id="categoryOrder" value="0" />
      </div>
      <div class="config-item">
        <label>Option Order</label>
        <input type="number" id="optionOrder" value="0" />
      </div>
      <div class="config-item">
        <label>Order Increment</label>
        <input type="number" id="orderIncrement" value="10" />
      </div>
    </div>

    <h4 style="margin-top: 20px; color: #0078ff;">Type-Specific Settings</h4>
    
    <div class="checkbox-wrapper">
      <input type="checkbox" id="useSeparateAttributes" checked />
      <label for="useSeparateAttributes">Use Separate Attributes (Recommended for readability)</label>
    </div>

    <h4 style="margin-top: 15px;">Boolean Options</h4>
    <div class="checkbox-wrapper">
      <input type="checkbox" id="boolUseButton" checked />
      <label for="boolUseButton">Use [ModOptionButton] for bools</label>
    </div>
    <div class="checkbox-wrapper">
      <input type="checkbox" id="boolUseArrows" />
      <label for="boolUseArrows">Use [ModOptionArrows] for bools</label>
    </div>

    <h4 style="margin-top: 15px;">Float/Int Options</h4>
    <div class="checkbox-wrapper">
      <input type="checkbox" id="numericUseSlider" checked />
      <label for="numericUseSlider">Use [ModOptionSlider] for float/int</label>
    </div>
    <div class="checkbox-wrapper">
      <input type="checkbox" id="numericGenerateValueSource" />
      <label for="numericGenerateValueSource">Generate custom value source method</label>
    </div>
    <div class="checkbox-wrapper">
      <input type="checkbox" id="separateValueSources" checked />
      <label for="separateValueSources">Output value source methods separately at the bottom</label>
    </div>

    <h4 style="margin-top: 15px;">Color Options</h4>
    <div class="checkbox-wrapper">
      <input type="checkbox" id="colorUseSlider" checked />
      <label for="colorUseSlider">Use RGBA sliders for colors (allows customization)</label>
    </div>
    <div class="checkbox-wrapper">
      <input type="checkbox" id="colorGenerateValueSource" />
      <label for="colorGenerateValueSource">Generate custom color presets instead</label>
    </div>
    <div class="config-grid" style="margin-top: 10px;">
      <div class="config-item">
        <label>Color Component Min</label>
        <input type="number" id="colorMin" value="0" step="0.1" />
      </div>
      <div class="config-item">
        <label>Color Component Max</label>
        <input type="number" id="colorMax" value="1" step="0.1" />
      </div>
      <div class="config-item">
        <label>Color Component Step</label>
        <input type="number" id="colorStep" value="0.01" step="0.001" />
      </div>
    </div>
    <div class="config-grid" style="margin-top: 10px;">
      <div class="config-item">
        <label>Float Min</label>
        <input type="number" id="floatMin" value="0" step="0.1" />
      </div>
      <div class="config-item">
        <label>Float Max</label>
        <input type="number" id="floatMax" value="100" step="0.1" />
      </div>
      <div class="config-item">
        <label>Float Step</label>
        <input type="number" id="floatStep" value="0.1" step="0.01" />
      </div>
      <div class="config-item">
        <label>Int Min</label>
        <input type="number" id="intMin" value="0" />
      </div>
      <div class="config-item">
        <label>Int Max</label>
        <input type="number" id="intMax" value="100" />
      </div>
      <div class="config-item">
        <label>Int Step</label>
        <input type="number" id="intStep" value="1" />
      </div>
    </div>

    <h4 style="margin-top: 15px;">Save Behavior</h4>
    <div class="checkbox-wrapper">
      <input type="checkbox" id="saveValues" checked />
      <label for="saveValues">Save values to player save file (default is true)</label>
    </div>

    <h4 style="margin-top: 15px;">Tooltips & Localization</h4>
    <div class="checkbox-wrapper">
      <input type="checkbox" id="addTooltips" />
      <label for="addTooltips">Add tooltip placeholders</label>
    </div>
    <div class="checkbox-wrapper">
      <input type="checkbox" id="addLocalization" />
      <label for="addLocalization">Add localization ID placeholders</label>
    </div>
  </div>
</div>

<div class="section">
  <h3>Input Code</h3>
  <div class="info">
    <strong>Supported formats:</strong><br>
    • <code>private const float MySpeed = 5.0f;</code><br>
    • <code>public static int MaxHealth = 100;</code><br>
    • <code>const bool EnableFeature = true;</code><br>
    • <code>float Range = 24;</code> (any variable declaration)<br>
    • <code>int Count;</code> (declarations without values)<br>
    • <code>Color MyColor = Color.red;</code> or <code>Color MyColor = new Color(1f, 0f, 1f);</code><br>
    • <code>string MyText = "Hello";</code><br>
    • Use the <strong>Category Name</strong> field above to group all options into a category.<br>
    • Supports: <code>float</code>, <code>int</code>, <code>bool</code>, <code>string</code>, <code>Color</code>
  </div>
  <textarea id="input" placeholder="float MySpeed = 5.0f;&#10;int MaxHealth = 100;&#10;bool EnableFeature = true;&#10;Color MyColor = new Color(1f, 0f, 1f);&#10;&#10;"></textarea>
</div>

<div class="button-group">
  <button id="loadReorder" style="background: linear-gradient(135deg, #ffc107 0%, #e0a800 100%);"> Load for Reordering</button>
  <button id="generate"> Generate ModOptions</button>
  <button id="copy" style="background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%);"> Copy to Clipboard</button>
  <button id="clear" style="background: linear-gradient(135deg, #dc3545 0%, #a71d2a 100%);"> Clear All</button>
</div>

<div class="section" id="reorderSection">
  <h3>Reorder Options</h3>
  <p>Drag items to reorder. Click "Generate ModOptions" after reordering to update output.</p>
  <ul id="reorderList" class="sortable"></ul>
</div>

<div class="section">
  <h3>Generated Output</h3>
  <div class="warning">
    <strong>⚠️ Important:</strong> Remember to add <code>static</code> to your generated members! All ModOptions must be static.
  </div>
  <pre id="output">// Your generated code will appear here...
// Paste your code in the input box above and click Generate!</pre>
    </div>
  </div>

  <script>
    const elements = {
      input: document.getElementById("input"),
      output: document.getElementById("output"),
      generate: document.getElementById("generate"),
      copy: document.getElementById("copy"),
      clear: document.getElementById("clear"),
      loadReorder: document.getElementById("loadReorder"),
      reorderList: document.getElementById("reorderList"),
      memberType: document.getElementById("memberType"),
      accessModifier: document.getElementById("accessModifier"),
      categoryName: document.getElementById("categoryName"),
      categoryOrder: document.getElementById("categoryOrder"),
      optionOrder: document.getElementById("optionOrder"),
      orderIncrement: document.getElementById("orderIncrement"),
      useSeparateAttributes: document.getElementById("useSeparateAttributes"),
      boolUseButton: document.getElementById("boolUseButton"),
      boolUseArrows: document.getElementById("boolUseArrows"),
      numericUseSlider: document.getElementById("numericUseSlider"),
      floatMin: document.getElementById("floatMin"),
      floatMax: document.getElementById("floatMax"),
      floatStep: document.getElementById("floatStep"),
      intMin: document.getElementById("intMin"),
      intMax: document.getElementById("intMax"),
      intStep: document.getElementById("intStep"),
      numericGenerateValueSource: document.getElementById("numericGenerateValueSource"),
      separateValueSources: document.getElementById("separateValueSources"),
      saveValues: document.getElementById("saveValues"),
      addTooltips: document.getElementById("addTooltips"),
      addLocalization: document.getElementById("addLocalization"),
      colorUseSlider: document.getElementById("colorUseSlider"),
      colorGenerateValueSource: document.getElementById("colorGenerateValueSource"),
      colorMin: document.getElementById("colorMin"),
      colorMax: document.getElementById("colorMax"),
      colorStep: document.getElementById("colorStep")
    };

    function toggleSection(id) {
      const content = document.getElementById(id);
      const toggle = document.getElementById(id.replace('Config', 'Toggle'));
      if (content.style.maxHeight === '0px') {
        content.style.maxHeight = '2000px';
        toggle.textContent = '▼';
      } else {
        content.style.maxHeight = '0px';
        toggle.textContent = '▶';
      }
    }

    function formatName(name) {
      return name.replace(/([A-Z])/g, " $1").trim();
    }

    function generateModOption(type, name, value, config) {
      const readableName = formatName(name);
      let lowerType = type.toLowerCase();
      let memberName = name;
      let cleanValue = value.trim();
      let valueSourceMethod = null;
      let valueSourceMethodName = null;

      let attributes = [];
      let modOptionParams = [];

      // Always add category and order attributes FIRST (before type-specific logic)
      if (config.categoryName) {
        if (config.useSeparateAttributes) {
          let catAttr = `[ModOptionCategory("${config.categoryName}"`;
          if (config.categoryOrder !== 0) {
            catAttr += `, ${config.categoryOrder}`;
          }
          catAttr += `)]`;
          attributes.push(catAttr);
        } else {
          modOptionParams.push(`category: "${config.categoryName}"`);
          if (config.categoryOrder !== 0) {
            modOptionParams.push(`categoryOrder: ${config.categoryOrder}`);
          }
        }
      }

      if (config.optionOrder !== 0) {
        if (config.useSeparateAttributes) {
          attributes.push(`[ModOptionOrder(${config.optionOrder})]`);
        } else {
          modOptionParams.push(`order: ${config.optionOrder}`);
        }
      }

      if (!config.saveValues) {
        if (config.useSeparateAttributes) {
          attributes.push(`[ModOptionDontSave]`);
        } else {
          modOptionParams.push(`saveValue: false`);
        }
      }

      if (lowerType === "float") {
        if (!cleanValue || cleanValue === "default") {
          cleanValue = "0.0f";
        } else {
          cleanValue = cleanValue.replace(/f$/i, "") + "f";
        }
        
        if (config.numericGenerateValueSource) {
          valueSourceMethodName = `${memberName}Options`;
          const min = parseFloat(config.floatMin);
          const max = parseFloat(config.floatMax);
          const step = parseFloat(config.floatStep);
          const count = Math.floor((max - min) / step) + 1;
          
          valueSourceMethod = `public static ModOptionFloat[] ${valueSourceMethodName}()
{
    var options = new ModOptionFloat[${count}];
    for (var i = 0; i < ${count}; i++)
    {
        var value = ${min}f + i * ${step}f;
        options[i] = new ModOptionFloat($"{value:F1}", value);
    }
    return options;
}`;
          
          modOptionParams.push(`nameof(${valueSourceMethodName})`);
        } else if (config.numericUseSlider) {
          attributes.push(`[ModOptionSlider]`);
          attributes.push(`[ModOptionFloatValues(${config.floatMin}f, ${config.floatMax}f, ${config.floatStep}f)]`);
        }
      } else if (lowerType === "int") {
        if (!cleanValue || cleanValue === "default") {
          cleanValue = "0";
        } else {
          cleanValue = cleanValue.replace(/[^0-9-]/g, "");
        }
        
        if (config.numericGenerateValueSource) {
          valueSourceMethodName = `${memberName}Options`;
          const min = parseInt(config.intMin);
          const max = parseInt(config.intMax);
          const step = parseInt(config.intStep);
          const count = Math.floor((max - min) / step) + 1;
          
          valueSourceMethod = `public static ModOptionInt[] ${valueSourceMethodName}()
{
    var options = new ModOptionInt[${count}];
    for (var i = 0; i < ${count}; i++)
    {
        var value = ${min} + i * ${step};
        options[i] = new ModOptionInt(value.ToString(), value);
    }
    return options;
}`;
          
          modOptionParams.push(`nameof(${valueSourceMethodName})`);
        } else if (config.numericUseSlider) {
          attributes.push(`[ModOptionSlider]`);
          attributes.push(`[ModOptionIntValues(${config.intMin}, ${config.intMax}, ${config.intStep})]`);
        }
      } else if (lowerType === "bool") {
        cleanValue = cleanValue.toLowerCase() === "true" ? "true" : "false";
        if (config.boolUseButton) {
          attributes.push(`[ModOptionButton]`);
        } else if (config.boolUseArrows) {
          attributes.push(`[ModOptionArrows]`);
        }
      } else if (lowerType === "string") {
        if (!cleanValue || cleanValue === "default") {
          cleanValue = '""';
        } else {
          if (!cleanValue.startsWith('"')) cleanValue = '"' + cleanValue;
          if (!cleanValue.endsWith('"')) cleanValue += '"';
        }
      } else if (lowerType === "color") {
        if (cleanValue.startsWith('"') && cleanValue.endsWith('"')) {
          cleanValue = cleanValue.slice(1, -1);
        }
        
        let r = 1, g = 1, b = 1, a = 1;
        
        if (cleanValue.startsWith('#')) {
          let hex = cleanValue.replace('#', '');
          if (hex.length === 3) {
            hex = hex.split('').map(c => c + c).join('');
          }
          r = parseInt(hex.substr(0, 2), 16) / 255;
          g = parseInt(hex.substr(2, 2), 16) / 255;
          b = parseInt(hex.substr(4, 2), 16) / 255;
          a = 1;
          if (hex.length === 8) {
            a = parseInt(hex.substr(6, 2), 16) / 255;
          }
          cleanValue = `new Color(${r.toFixed(3)}f, ${g.toFixed(3)}f, ${b.toFixed(3)}f, ${a.toFixed(3)}f)`;
        } else if (cleanValue.startsWith('new Color')) {
          // Extract values from new Color(r, g, b, a) format
          const match = cleanValue.match(/new Color\(([\d.]+)f?,\s*([\d.]+)f?,\s*([\d.]+)f?(?:,\s*([\d.]+)f?)?\)/);
          if (match) {
            r = parseFloat(match[1]);
            g = parseFloat(match[2]);
            b = parseFloat(match[3]);
            a = match[4] ? parseFloat(match[4]) : 1;
          }
        } else if (cleanValue.startsWith('Color.')) {
          // Keep default Unity colors as-is
          const colorMap = {
            'Color.red': [1, 0, 0, 1],
            'Color.green': [0, 1, 0, 1],
            'Color.blue': [0, 0, 1, 1],
            'Color.white': [1, 1, 1, 1],
            'Color.black': [0, 0, 0, 1],
            'Color.yellow': [1, 0.92, 0.016, 1],
            'Color.cyan': [0, 1, 1, 1],
            'Color.magenta': [1, 0, 1, 1],
            'Color.gray': [0.5, 0.5, 0.5, 1],
            'Color.grey': [0.5, 0.5, 0.5, 1]
          };
          const colorKey = cleanValue.split('(')[0];
          if (colorMap[colorKey]) {
            [r, g, b, a] = colorMap[colorKey];
          }
        } else if (!cleanValue || cleanValue === 'default') {
          cleanValue = "new Color(1f, 1f, 1f, 1f)";
        }

        if (config.colorUseSlider) {
          // Generate 4 separate properties for RGBA with sliders
          // Base attributes include category, save settings, tooltips - everything EXCEPT order and ModOption
          const baseAttributesForColor = [];
          
          // Add category
          if (config.categoryName) {
            if (config.useSeparateAttributes) {
              let catAttr = `[ModOptionCategory("${config.categoryName}"`;
              if (config.categoryOrder !== 0) {
                catAttr += `, ${config.categoryOrder}`;
              }
              catAttr += `)]`;
              baseAttributesForColor.push(catAttr);
            }
          }
          
          // Add save behavior
          if (!config.saveValues) {
            if (config.useSeparateAttributes) {
              baseAttributesForColor.push(`[ModOptionDontSave]`);
            }
          }
          
          // Add tooltips if enabled
          if (config.addTooltips) {
            if (config.useSeparateAttributes) {
              let tooltipAttr = `[ModOptionTooltip("Color component for ${readableName}"`;
              if (config.addLocalization) {
                tooltipAttr += `, "YourMod.${memberName}.Tooltip"`;
              }
              tooltipAttr += `)]`;
              baseAttributesForColor.push(tooltipAttr);
            }
          }
          
          const colorMin = parseFloat(config.colorMin) || 0;
          const colorMax = parseFloat(config.colorMax) || 1;
          const colorStep = parseFloat(config.colorStep) || 0.01;
          
          // Calculate order increments for color components
          const baseOrder = config.optionOrder;
          
          // Red component
          let rAttributes = [...baseAttributesForColor];
          if (baseOrder !== 0) {
            rAttributes.push(`[ModOptionOrder(${baseOrder})]`);
          }
          rAttributes.push(`[ModOptionSlider]`);
          rAttributes.push(`[ModOptionFloatValues(${colorMin.toFixed(2)}f, ${colorMax.toFixed(2)}f, ${colorStep.toFixed(3)}f)]`);
          rAttributes.push(`[ModOption("${readableName} - Red")]`);
          
          let rDeclaration = "";
          if (config.memberType === "field") {
            rDeclaration = `${config.accessModifier} static float ${memberName}_R = ${r.toFixed(3)}f;`;
          } else if (config.memberType === "property") {
            rDeclaration = `${config.accessModifier} static float ${memberName}_R { get; set; } = ${r.toFixed(3)}f;`;
          }
          
          // Green component
          let gAttributes = [...baseAttributesForColor];
          if (baseOrder !== 0) {
            gAttributes.push(`[ModOptionOrder(${baseOrder + 1})]`);
          }
          gAttributes.push(`[ModOptionSlider]`);
          gAttributes.push(`[ModOptionFloatValues(${colorMin.toFixed(2)}f, ${colorMax.toFixed(2)}f, ${colorStep.toFixed(3)}f)]`);
          gAttributes.push(`[ModOption("${readableName} - Green")]`);
          
          let gDeclaration = "";
          if (config.memberType === "field") {
            gDeclaration = `${config.accessModifier} static float ${memberName}_G = ${g.toFixed(3)}f;`;
          } else if (config.memberType === "property") {
            gDeclaration = `${config.accessModifier} static float ${memberName}_G { get; set; } = ${g.toFixed(3)}f;`;
          }
          
          // Blue component
          let bAttributes = [...baseAttributesForColor];
          if (baseOrder !== 0) {
            bAttributes.push(`[ModOptionOrder(${baseOrder + 2})]`);
          }
          bAttributes.push(`[ModOptionSlider]`);
          bAttributes.push(`[ModOptionFloatValues(${colorMin.toFixed(2)}f, ${colorMax.toFixed(2)}f, ${colorStep.toFixed(3)}f)]`);
          bAttributes.push(`[ModOption("${readableName} - Blue")]`);
          
          let bDeclaration = "";
          if (config.memberType === "field") {
            bDeclaration = `${config.accessModifier} static float ${memberName}_B = ${b.toFixed(3)}f;`;
          } else if (config.memberType === "property") {
            bDeclaration = `${config.accessModifier} static float ${memberName}_B { get; set; } = ${b.toFixed(3)}f;`;
          }
          
          // Alpha component
          let aAttributes = [...baseAttributesForColor];
          if (baseOrder !== 0) {
            aAttributes.push(`[ModOptionOrder(${baseOrder + 3})]`);
          }
          aAttributes.push(`[ModOptionSlider]`);
          aAttributes.push(`[ModOptionFloatValues(${colorMin.toFixed(2)}f, ${colorMax.toFixed(2)}f, ${colorStep.toFixed(3)}f)]`);
          aAttributes.push(`[ModOption("${readableName} - Alpha")]`);
          
          let aDeclaration = "";
          if (config.memberType === "field") {
            aDeclaration = `${config.accessModifier} static float ${memberName}_A = ${a.toFixed(3)}f;`;
          } else if (config.memberType === "property") {
            aDeclaration = `${config.accessModifier} static float ${memberName}_A { get; set; } = ${a.toFixed(3)}f;`;
          }
          
          // Helper property to get the Color
          const helperComment = `// Helper property to get the color from RGBA components`;
          let helperDeclaration = `public static Color ${memberName} => new Color(${memberName}_R, ${memberName}_G, ${memberName}_B, ${memberName}_A);`;
          
          return {
            code: rAttributes.join("\n") + "\n" + rDeclaration + "\n\n" +
                  gAttributes.join("\n") + "\n" + gDeclaration + "\n\n" +
                  bAttributes.join("\n") + "\n" + bDeclaration + "\n\n" +
                  aAttributes.join("\n") + "\n" + aDeclaration + "\n\n" +
                  helperComment + "\n" + helperDeclaration,
            valueSourceMethod: null,
            valueSourceMethodName: null
          };
        } else if (config.colorGenerateValueSource) {
          // Generate a method with color presets
          valueSourceMethodName = `${memberName}Options`;
          valueSourceMethod = `public static ModOptionColor[] ${valueSourceMethodName}()
{
    return new ModOptionColor[]
    {
        new ModOptionColor("Red", Color.red),
        new ModOptionColor("Green", Color.green),
        new ModOptionColor("Blue", Color.blue),
        new ModOptionColor("Yellow", Color.yellow),
        new ModOptionColor("Cyan", Color.cyan),
        new ModOptionColor("Magenta", Color.magenta),
        new ModOptionColor("White", Color.white),
        new ModOptionColor("Black", Color.black),
        new ModOptionColor("Custom", ${cleanValue})
    };
}`;
          modOptionParams.push(`nameof(${valueSourceMethodName})`);
        }
      }

      if (config.addTooltips) {
        if (config.useSeparateAttributes) {
          let tooltipAttr = `[ModOptionTooltip("Description for ${readableName}"`;
          if (config.addLocalization) {
            tooltipAttr += `, "YourMod.${memberName}.Tooltip"`;
          }
          tooltipAttr += `)]`;
          attributes.push(tooltipAttr);
        } else {
          modOptionParams.push(`tooltip: "Description for ${readableName}"`);
          if (config.addLocalization) {
            modOptionParams.push(`tooltipLocalizationId: "YourMod.${memberName}.Tooltip"`);
          }
        }
      }

      let modOptionAttr = `[ModOption("${readableName}"`;
      
      if (modOptionParams.length > 0) {
        modOptionAttr += `, ${modOptionParams.join(", ")}`;
      }
      
      if (config.addLocalization && !modOptionParams.some(p => p.includes('titleLocalizationId'))) {
        const locId = `titleLocalizationId: "YourMod.${memberName}.Title"`;
        if (modOptionParams.length > 0) {
          modOptionAttr += `, ${locId}`;
        } else {
          modOptionAttr += `, ${locId}`;
        }
      }
      
      modOptionAttr += `)]`;
      attributes.push(modOptionAttr);

      let memberDeclaration = "";
      const access = config.accessModifier;
      
      if (config.memberType === "field") {
        memberDeclaration = `${access} static ${type} ${memberName} = ${cleanValue};`;
      } else if (config.memberType === "property") {
        memberDeclaration = `${access} static ${type} ${memberName} { get; set; } = ${cleanValue};`;
      } else if (config.memberType === "method") {
        memberDeclaration = `${access} static void ${memberName}(${type} value)\n{\n    // TODO: Implement logic for ${readableName}\n}`;
      }

      let result = attributes.join("\n") + "\n" + memberDeclaration;
      
      return {
        code: result,
        valueSourceMethod: valueSourceMethod,
        valueSourceMethodName: valueSourceMethodName
      };
    }

    function getDefaultValue(type) {
      const lowerType = type.toLowerCase();
      switch (lowerType) {
        case "float": return "0.0f";
        case "int": return "0";
        case "bool": return "false";
        case "string": return '""';
        case "color": return "Color.white";
        default: return "default";
      }
    }

    function loadToReorder() {
      const code = elements.input.value;
      const regex = /(?:private|public|protected|internal|static|const|readonly)?\s*(\w+)\s+(\w+)\s*(?:=\s*([^;]+))?;/gi;
      const options = [];
      code.split('\n').forEach(line => {
        line = line.trim();
        let match;
        regex.lastIndex = 0;
        if ((match = regex.exec(line))) {
          let [, type, name, value] = match;
          options.push({type, name, value: value || getDefaultValue(type)});
        }
      });
      const list = elements.reorderList;
      list.innerHTML = '';
      options.forEach(opt => {
        const li = document.createElement('li');
        li.textContent = `${opt.type} ${opt.name} = ${opt.value}`;
        li.dataset.type = opt.type;
        li.dataset.name = opt.name;
        li.dataset.value = opt.value;
        li.draggable = true;
        list.appendChild(li);
      });
    }

    function generate() {
      const config = {
        memberType: elements.memberType.value,
        accessModifier: elements.accessModifier.value,
        categoryName: elements.categoryName.value.trim(),
        categoryOrder: parseInt(elements.categoryOrder.value) || 0,
        optionOrder: parseInt(elements.optionOrder.value) || 0,
        orderIncrement: parseInt(elements.orderIncrement.value) || 10,
        useSeparateAttributes: elements.useSeparateAttributes.checked,
        boolUseButton: elements.boolUseButton.checked,
        boolUseArrows: elements.boolUseArrows.checked,
        numericUseSlider: elements.numericUseSlider.checked,
        floatMin: elements.floatMin.value,
        floatMax: elements.floatMax.value,
        floatStep: elements.floatStep.value,
        intMin: elements.intMin.value,
        intMax: elements.intMax.value,
        intStep: elements.intStep.value,
        numericGenerateValueSource: elements.numericGenerateValueSource.checked,
        separateValueSources: elements.separateValueSources.checked,
        saveValues: elements.saveValues.checked,
        addTooltips: elements.addTooltips.checked,
        addLocalization: elements.addLocalization.checked,
        colorUseSlider: elements.colorUseSlider.checked,
        colorGenerateValueSource: elements.colorGenerateValueSource.checked,
        colorMin: elements.colorMin.value,
        colorMax: elements.colorMax.value,
        colorStep: elements.colorStep.value
      };

      const list = elements.reorderList;
      let results = [];
      let valueSources = [];
      const regex = /(?:private|public|protected|internal|static|const|readonly)?\s*(\w+)\s+(\w+)\s*(?:=\s*([^;]+))?;/gi;

      if (list.children.length > 0) {
        let order = config.optionOrder;
        Array.from(list.children).forEach((li, index) => {
          const type = li.dataset.type;
          const name = li.dataset.name;
          const value = li.dataset.value;
          let localConfig = { ...config, optionOrder: order + index * config.orderIncrement };
          const result = generateModOption(type, name, value, localConfig);
          results.push(result.code);
          if (result.valueSourceMethod) {
            valueSources.push(result.valueSourceMethod);
          }
        });
      } else {
        const code = elements.input.value;
        let order = config.optionOrder;
        code.split('\n').forEach(line => {
          line = line.trim();
          let match;
          regex.lastIndex = 0;
          if ((match = regex.exec(line))) {
            let [, type, name, value] = match;
            let localConfig = { ...config, optionOrder: order };
            const result = generateModOption(type, name, value || getDefaultValue(type), localConfig);
            results.push(result.code);
            if (result.valueSourceMethod) {
              valueSources.push(result.valueSourceMethod);
            }
            order += config.orderIncrement;
          }
        });
      }

      if (results.length === 0) {
        elements.output.textContent = `// Nothing detected in input
// Supported formats:
// private float MyValue = 5.0f;
// public static int Count = 10;
// const bool IsEnabled = true;
//
// Make sure your declarations end with semicolons!`;
      } else {
        let output = "";
        
        if (config.separateValueSources && valueSources.length > 0) {
          output += "// ===== ModOption Declarations =====\n\n";
          output += results.join("\n\n");
          output += "\n\n// ===== Value Source Methods =====\n";
          output += "// Place these at the bottom of your class or in a separate region\n\n";
          output += valueSources.join("\n\n");
        } else {
          output = results.join("\n\n");
        }
        
        elements.output.textContent = output;
      }
    }

    function makeSortable() {
      const sortable = elements.reorderList;
      sortable.addEventListener('dragstart', e => {
        e.target.classList.add('dragging');
      });
      sortable.addEventListener('dragend', e => {
        e.target.classList.remove('dragging');
      });
      sortable.addEventListener('dragover', e => {
        e.preventDefault();
        const afterElement = getDragAfterElement(sortable, e.clientY);
        const draggable = document.querySelector('.dragging');
        if (afterElement == null) {
          sortable.appendChild(draggable);
        } else {
          sortable.insertBefore(draggable, afterElement);
        }
      });
    }

    function getDragAfterElement(container, y) {
      const draggableElements = [...container.querySelectorAll('li:not(.dragging)')];
      return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
          return { offset: offset, element: child };
        } else {
          return closest;
        }
      }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    elements.loadReorder.addEventListener("click", loadToReorder);
    elements.generate.addEventListener("click", generate);

    elements.copy.addEventListener("click", async () => {
      const text = elements.output.textContent;
      if (text && !text.startsWith("//")) {
        try {
          await navigator.clipboard.writeText(text);
          const originalText = elements.copy.textContent;
          elements.copy.textContent = " ✓ Copied!";
          setTimeout(() => {
            elements.copy.textContent = originalText;
          }, 2000);
        } catch (err) {
          alert("Failed to copy to clipboard");
        }
      }
    });

    elements.clear.addEventListener("click", () => {
      if (confirm("Clear input and output?")) {
        elements.input.value = "";
        elements.reorderList.innerHTML = "";
        elements.output.textContent = "// Your generated code will appear here...\n// Paste your code in the input box above and click Generate!";
      }
    });

    elements.boolUseButton.addEventListener("change", () => {
      if (elements.boolUseButton.checked) {
        elements.boolUseArrows.checked = false;
      }
    });

    elements.boolUseArrows.addEventListener("change", () => {
      if (elements.boolUseArrows.checked) {
        elements.boolUseButton.checked = false;
      }
    });

    elements.colorUseSlider.addEventListener("change", () => {
      if (elements.colorUseSlider.checked) {
        elements.colorGenerateValueSource.checked = false;
      }
    });

    elements.colorGenerateValueSource.addEventListener("change", () => {
      if (elements.colorGenerateValueSource.checked) {
        elements.colorUseSlider.checked = false;
      }
    });

    let debounceTimer;
    elements.input.addEventListener("input", () => {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => {
        elements.reorderList.innerHTML = "";
        generate();
      }, 700);
    });

    makeSortable();
  </script>
</body>
</html>



